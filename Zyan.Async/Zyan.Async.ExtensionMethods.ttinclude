<#
// Extension method generator.
//
// Inspects all loaded assemblies, extracts interface types.
// For every interface creates static class with asynchronous extension methods.
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".Generated.cs" #>
// Rewriting XML comments is not supported
#pragma warning disable 1591

<#
	// ignore lists
	var asmIgnoreList = "^(mscorlib|Microsoft|System|WindowsBase|EnvDTE|Accessibility|UltimaLib|Zyan.Communication)";
	var typeIgnoreList = "^(Microsoft.VisualStudio.TextTemplating)";
	var methodIgnoreList = "^(get_|set_|add_|remove)";

	Func<Type, bool> typeFilter = t =>
		t.IsInterface && 
		!Regex.IsMatch(t.Name, typeIgnoreList) &&
		!System.Attribute.IsDefined(t, typeof(System.Runtime.CompilerServices.CompilerGeneratedAttribute)) &&
		t.GetMethods().Any(m => !Regex.IsMatch(m.Name, methodIgnoreList));

	// get loaded assemblies containing interfaces
	var asms =
		from asm in AppDomain.CurrentDomain.GetAssemblies()
		where !Regex.IsMatch(asm.GetName().Name, asmIgnoreList) && GetTypes(asm).Any(typeFilter)
		orderby asm.FullName
		select asm;

	// process every assembly containing interfaces
	foreach (var asm in asms)
	{
		#>// Assembly name: <#= asm.FullName #>
<#
		// emit extension class for each interface
		foreach (var type in GetTypes(asm).Where(typeFilter))
		{
#>namespace <#= GetClientNamespace(type) #>
{
	/// <summary>
	/// Asynchronous extension methods for the <see cref="<#= type.FullName #>" /> interface.
	/// </summary>
	public static class <#= GetNonGenericTypeName(type.Name) #>AsyncExtensions
	{
<#
			// create asynchronous extension method for every synchronous method
			foreach (var method in type.GetMethods().Where(m => !Regex.IsMatch(m.Name, methodIgnoreList)))
			{
				var methodParameters = method.GetParameters();
				if (methodParameters.Any(p => p.IsOut || p.IsRetval || p.ParameterType.IsPointer || p.ParameterType.IsByRef))
				{
					// methods with ref/out parameters cannot be async
					continue;
				}

				var returnType = method.ReturnType;
				if (returnType == typeof(void) || returnType == typeof(Task))
				{
					returnType = typeof(Task);
				}
				else
				{
					returnType = typeof(Task<>).MakeGenericType(returnType);
				}

				var genericParameters = string.Empty;
				var genericConstraints = Enumerable.Empty<string>();
				var genericArguments = Enumerable.Empty<Type>();
				var methodGenericParameters = string.Empty;
				if (method.DeclaringType.IsGenericType)
				{
					genericArguments = method.DeclaringType.GetGenericTypeDefinition().GetGenericArguments().AsEnumerable();
				}

				if (method.IsGenericMethod)
				{
					genericArguments = genericArguments.Concat(method.GetGenericArguments());
					methodGenericParameters = "<" + string.Join(", ", method.GetGenericArguments().Select(t => GetTypeName(t))) + ">";;
				}

				if (genericArguments.Any())
				{
					genericParameters = "<" + string.Join(", ", genericArguments.Select(t => GetTypeName(t))) + ">";
					genericConstraints = genericArguments.Select(t => GetTypeConstraints(t)).Where(c => c != null);
				}

				var parameters = string.Join(", ", method.GetParameters().Select(p =>
				{
					var defaultValue = string.Empty;
					if (p.HasDefaultValue)
					{
						defaultValue = " = " + GetValueLiteral(p.DefaultValue);
					}

					return (Attribute.IsDefined(p, typeof(ParamArrayAttribute)) ? "params " : string.Empty) +
						GetTypeName(p.ParameterType) + " " + p.Name + defaultValue;
				}));

				if (!string.IsNullOrEmpty(parameters))
				{
					parameters = ", " + parameters; 
				}
				
				var actualParameters = string.Join(", ", method.GetParameters().Select(p => p.Name));

#>		// <#= method #>
		public static <#= GetTypeName(returnType) #> <#= method.Name #>Async<#= genericParameters #>(this <#= GetTypeName(type) #> self<#= parameters#>)
<# 
			// emit generic constraints
			foreach (var constraint in genericConstraints)
			{
#>			<#= constraint #>
<#
			}
#>
		{
			return System.Threading.Tasks.Task.Run(() => self.<#= method.Name #><#= methodGenericParameters #>(<#= actualParameters #>));
		}

<#
			}
#>	}
} // <#= GetClientNamespace(type) #>.<#= GetNonGenericTypeName(type.Name) #>AsyncExtensions

<#
		}
	}
#>
<#+
	internal string GetTypeName(Type type)
	{
		if (type == null)
		{
			return string.Empty;
		}

		if (type.IsGenericType)
		{
			var typeArguments = string.Join(", ", type.GetGenericArguments().Select(x => GetTypeName(x)));
			return Regex.Replace(type.GetGenericTypeDefinition().FullName, @"`.+$", "") + "<" + typeArguments + ">";
		}

		if (type.IsArray)
		{
			var rank = new string(',', type.GetArrayRank() - 1);
			return GetTypeName(type.GetElementType()) + "[" + rank + "]";
		}

		return (type.FullName ?? type.Name).Replace("+", ".");
	}

	internal string GetNonGenericTypeName(string typeName)
	{
		return Regex.Replace(typeName, @"`.+$", "");
	}

	internal string GetTypeConstraints(Type type)
	{
		var constraints = type
			.GetGenericParameterConstraints()
			.Where(t => t != typeof(ValueType))
			.Select(t => GetTypeName(t))
			.ToList();

		var attrs = type.GenericParameterAttributes;
		if ((attrs & GenericParameterAttributes.ReferenceTypeConstraint) != 0)
		{
			constraints.Insert(0, "class");
		}

		if ((attrs & GenericParameterAttributes.NotNullableValueTypeConstraint) != 0)
		{
			constraints.Insert(0, "struct");
		}

		if ((attrs & GenericParameterAttributes.DefaultConstructorConstraint) != 0 &&
			(attrs & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0)
		{
			constraints.Add("new()");
		}

		if (constraints.Any())
		{
			return "where " + type.Name + " : " + string.Join(", ", constraints);
		}

		return null;
	}

	internal string GetValueLiteral(object value)
	{
		if (value == null)
		{
			return "null";
		}

		if (value is bool)
		{
			return value.ToString().ToLower();
		}

		if (value is Enum)
		{
			return string.Format("{0}.{1}", GetTypeName(value.GetType()), value);
		}

		var invariantCulture = System.Globalization.CultureInfo.InvariantCulture;
		if (value is decimal)
		{
			return string.Format(invariantCulture, "{0}M", value);
		}

		if (value is float)
		{
			return string.Format(invariantCulture, "{0}F", value);
		}

		if (value is double)
		{
			return string.Format(invariantCulture, "{0}D", value);
		}

		if (value is long)
		{
			return value.ToString() + "L";
		}

		if (value is ulong)
		{
			return value.ToString() + "UL";
		}

		if (value is short)
		{
			return value.ToString() + "S";
		}

		if (value is ushort)
		{
			return value.ToString() + "US";
		}

		if (value is uint)
		{
			return value.ToString() + "U";
		}

		if (value is string)
		{
			return string.Format(@"@""{0}""", (value as string).Replace("\"", "\"\""));
		}

		return value.ToString();
	}

	private string GetClientNamespace(Type type)
	{
		return type.Namespace;
	}

	private IEnumerable<Type> GetTypes(Assembly asm)
	{
		try
		{
			return asm.GetTypes();
		}
		catch (Exception ex)
		{
			System.Diagnostics.Trace.WriteLine("T4", "Cannot load types because of exception: {0}" + ex.ToString());
		}

		return Enumerable.Empty<Type>();
	}
#>
